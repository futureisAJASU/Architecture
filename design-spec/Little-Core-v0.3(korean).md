이 문서는 Little Core Architecture v0.3의 설계 의도와 구조적 선택을 하나의 흐름으로 설명하기 위해 작성했으며, 목표는 항상 켜져 있어야 하는 모바일 워크로드(백그라운드·UI·시스템 태스크)를 최소 전력으로 지속 처리하면서도, 짧은 버스트 작업(스크롤·앱 전환·간단한 벡터/AI 연산)에 지연 없이 반응하고, 그 과정에서 전통적인 고성능 코어처럼 복잡한 대형 스케줄러·광폭 파이프라인·거대한 ROB를 통해 brute force로 성능을 뽑아내기보다 컨트롤 중심의 효율을 극대화하는 것에 있다. 따라서 본 코어는 단순하지만 똑똑한 흐름 제어, 공유 유닛과 적극적인 파워 게이팅, 프론트엔드에서 얻는 힌트 기반의 사전 웨이크업을 핵심 철학으로 삼고, 전체 구조는 shared L2$(클러스터당 512KB-1MB) 위에 32KB 4-way L1i를 두되 단순히 용량을 늘리기보다 way prediction과 공격적인인 power gating을 통해 불필요한 태그/데이터 접근을 줄여 접근 에너지를 낮추는 방향으로 최적화하며, fetch는 32B/cycle로 비교적 여유 있게 가져가되 decoder는 3-wide로 제한해 ARM 명령 밀도 특성상 fetch 폭을 과도하게 줄일 필요는 없지만 디코딩 폭 증가가 전력 대비 효율을 빠르게 악화시키는 점을 고려해 IPC 자체 극대화보다 IPC/W를 노리는 선택을 한다. fetch 단계에서 predecoder를 통합하여 명령어에 대한 메타 태그, 분류를 우선 실행하여 추후에 설명할 게이팅된(off된) 블록을 미리 깨우는 역할을 수행할 수 있도록 한다. 분기 예측은 복잡한 하이브리드 예측기 대신 light Gshare + light local history table + small BTB로 구성해 예측기의 자체 전력과 면적을 억제하고, 대신 파이프라인 자체를 지나치게 깊게 만들지 않아 예측 실패시의 비용을 구조적으로 낮추는 방향을 취하며, 디코딩 이후에는 Thin&Light Renaming을 4-wide 정도로 두어 완전한 OoO를 위한 공격적 리네이밍이 아니라 의존성 완화와 최소한의 병렬성 확보를 목적에 두고 리네이밍 로직의 복잡도와 에너지를 억제하며, ROB는 64-entry로 설정해 정합성 유지와 커밋 순서 보장 및 store commit 시점 제어라는 정확성/메모리 질서의 역할을 중심으로 두되, 고성능 코어처럼 speculation window를 크게 키워 성능을 최대 목적으로써 공격적으로 올리는 목적은 지양한다. 본 설계의 핵심 블록은 Central Dispatcher + Queue Classifier(CD+QC)로, 전통적인 OoO 스케줄러가 요구하는 wake-up 네트워크, CAM 기반 비교, 광범위한 ready 검사와 큰 fan-out이 전력·면적·클럭에 불리하고 특히 리틀코어 워크로드에서는 그 비용 대비 이득이 제한적이라는 판단 아래, 나중에 실행단에서 최적의 명령을 고르는 방식 대신 초기에 명령을 정확히 분류하고, 필요한 경로만 열고, 필요한 유닛만 미리 깨워 실행 시점의 지연을 제거하는 컨트롤 중심 구조를 선택했으며, QC는 단순 라우터가 아니라 디코딩 결과와 프리디코드(또는 fetch 단계에서 생성된 class hint)를 결합해 명령의 클래스(INT0/INT1/LD·ST/FP scalar/Vector·SME2/Shared MUL·DIV 등)를 확정하고 그 확정 결과를 바탕으로 목적 큐에 전달하는 동시에 downstream 큐와 공유 유닛을 사전에 wake-up하여 실행 직전 웨이크업 지연을 최소화한다. Issue 정책 또한 전통적인 명시적 Issue Scheduler를 두지 않는 것이 의도적 차별점으로, 리틀코어 영역에서는 가장 좋은 명령을 고르는 문제보다 막히지 않고 흘려보내는 문제가 지배적이고, load miss나 일부 long-latency가 전체를 멈추는 것을 피하는 쪽이 체감 효율에 더 중요하다는 판단 하에서서, 각 큐는 깊이를 과도하게 키우기보다 Head + N(예: 1-4) 범위의 준비 상태만 검사해 준비된 엔트리가 있으면 즉시 issue하는 근사 정책(Head+N skip)을 사용하며, 이는 CAM 기반 복잡한 선택을 피하면서도 대부분의 단순 의존성과 단일 long-latency로 인한 정체를 완화할 수 있고, ALU direct issue 형태로 중간 단계(복잡한 scheduler)를 두지 않고 실행 유닛으로 바로 흘려 레이턴시를 줄이며 컨트롤 로직을 단순화한다. 실행 유닛은 Full-stack ALU(INT 0)와 Light ALU(INT 1)를 분리해 대부분 빈번한 단순 연산(add/and 등)은 light 경로에서 처리하고 분기 비교나 복잡한 시프트/비트 연산 등은 full-stack에서 처리함으로써 항상 복잡한 ALU를 전부 켜두는 낭비를 줄이고, 면적을 최소화 하도록 한다. 또한 사용 빈도가 낮고 전력 소모가 큰 MUL/DIV는 shared MUL/DIV로 클러스터간 완전 공유하며 기본은 full power gating으로 OFF 상태를 유지하고, 프리디코드 힌트 및 QC의 클래스 확정 신호를 트리거로 predecode-triggered wake-up을 걸어 필요해지면 깨우는 방식보다 필요할 것을 미리 예측해 짧게 시동하는 방식으로 지연을 줄이되, 사용이 끝나면 빠르게 다시 끄는 정책과 결합하여 빠른 처리 및 sleep 정책을 적용한다. FP/Vector/SME2 역시 리틀코어에서 상시 필요한 자원이 아니고 burst 성향이 강하므로 전용으로 크게 두기보다 shared RF 아래에서 FP scalar와 Vector/SME2를 공유 구조로 두고, 평상시에는 통째로 aggressive gating을 적용하며, 대신 burst 시 병목을 줄이기 위해 관련 큐(Shared FP/Vector queue)와 Data Queue를 넉넉하게 잡는 방향을 취할 수 있는데, v0.3에서는 shared 유닛 큐 부족 가능성을 고려해 shared MUL/DIV를 8-entry로 키우고, Data Queue도 16+4(input 16, weight(AI 가중치 연산) 4)처럼 burst에 대비한 완충을 두되, 안 쓸 때는 통째로 OFF를 전제로 큐 뱅크를 지나치게 쪼개 복잡도를 올리기보다 단순하게 키우고 끄는 쪽이 전력·설계 복잡도 측면에서 합리적이라는 판단을 반영하였다. 메모리 서브시스템은 AGU를 두고 Store Buffer를 16-entry로 넉넉히 잡아 store가 작은 SB로 인해 전체 파이프라인을 막는 상황을 줄이고, load는 Load Logic(또는 간소 LSQ)와 L1D를 통해 처리하며 SB address compare를 통해 store-to-load forwarding/ordering을 단순화하고, miss 처리의 동시성을 위해 MSHR을 기본 4-entry에 필요 시 켜지는 추가 4-entry gated extension(4+4)로 구성해 면적 증가를 크게 유발하지 않는 선에서 병렬 miss 처리 능력을 확보하며, fill path를 통해 L2로 연결되는 경로를 명확히 둔다. 이 역시 프리디코더/ 큐 점유율 등을 토대로 가변적인 확장을 구현한다. 또한 direct bypass for AI compute는 반복적인 MAC 연산을 쓰는 AI 연산 특성상 결과값을 그대로 사용하여 연산할 가능성이 매우 높으므로, 연산 직후 LD/ST 과정을 생략하고 바로 연산 유닛으로 직행하여 연산을 재개할 수 있도록 한다. 또한 CD+QC가 프리디코드 단계에서 생성된 early class hint를 디코딩/분류 결과로 최종 확정하면서 그 확정 신호를 이용해 downstream 큐와 공유 유닛을 실행 전에 선제적으로 깨우도록 주석을 명시한 것은 predecoding 단계의 명시와 힌트 생성(조기) → 확정(후속) → 웨이크업 트리거(확정 기반)라는 타이밍을 분명히 하여, 필요한 순간에만 전력을 쓰되 실행 시점의 지연은 최소화하는 목적을 구조적으로 설명하기 위한 것이다. 이 설계는 결과적으로 스케줄링을 잘하는 코어가 아니라 스케줄링이 필요 없도록 흐름을 설계한 코어를 지향하며, 전통적 OoO issue scheduler를 제거한 대신 중앙 분류와 제한적 스캔(Head+N)으로 근사 스케줄을 수행하고, 사전 웨이크업과 강한 파워 게이팅을 결합해 리틀코어가 담당해야 하는 상시 작업에서 IPC/W를 최대화하며, 필요 시에만 공유 유닛을 깨워 burst를 흡수하는 구조를 만든다. ARM Cortex-A5xx 계열은 대체로 “작고 단순한 코어”라는 목표 아래 in-order 또는 제한적 OoO와 정적인 파이프라인을 통해 낮은 복잡도를 선택하는 경향이 있고, 본 설계는 단순히 폭을 키우기보다는 “분류+사전 웨이크업+공유 유닛 완전 게이팅” 같은 컨트롤 중심 최적화를 전면에 둔다는 점에서 철학적 차이가 있으며, 특히 본 설계의 CD+QC는 유닛이 필요해진 뒤 깨우는 사후 대응이 아니라 필요할 가능성을 조기에 포착해 깨우는 사전 제어를 강조하며, 기존 scheduler를 대신하여 알맞은 연산 유닛이 있는 큐에 할당하도록 하는 구조임이 중요한 차별점이다. 또한 이 구조는 리틀에서 끝나는 것이 아니라 스케일링을 전제로 해 미들로 확장할 때 디코더 폭을 3에서 56으로 늘리고 ROB를 64에서 128~192로 확장하며 큐 깊이를 늘리고 Head+N 범위를 조정하는 식으로 성능을 확장하되, 핵심인 중앙 분류+사전 웨이크업 골격은 유지할 수 있고, 미들에서는 전체 OoO 스케줄러를 무조건 도입하기보다 LD/ST나 FP/Vector 일부에만 제한적으로 scheduler 성격의 기능을 추가하는 식으로 선택적 스케줄링을 도입해 전력 폭증을 피하는 방향이 자연스럽다. 빅코어로 가면 branch predictor 고도화, 더 큰 ROB/폭 확대, 더 강한 실행 폭을 넣을 수 있지만, 여전히 분류-디스패치-공유 유닛이라는 상위 구조를 유지할 수 있어 설계 패밀리로 확장하기 쉬운 편이다. 그럼에도 여전히 본 형식은 현대의 OoO 방식식에서 완전히 검증되지 않았으므로 이 영역에 대해서는 추가적인 연구가 필요하다. 구현 로드맵 관점에서는 지금 단계의 목적이 ARM ISA를 완전 실행시키는 것이 아니라 컨트롤 플로우, 큐 압력, 스톨 조건, 웨이크업 타이밍의 타당성을 검증하는 데 있으므로, Logisim 같은 사이클 단위 시각화에 강한 환경에서 CD+QC, 큐 fill/empty, Head+N skip, 웨이크업 FSM, ROB의 최소 커밋 모델부터 구성해 병목과 타이밍을 먼저 잡고, 이후 구조가 안정화되어 검증이 완료되면 ALU/AGU/큐 일부를 RTL로 옮기는 하이브리드 단계를 거쳐 최종적으로 full RTL에서 IPC/W와 레이턴시 등 정량 지표를 측정 및 최종 구현하는 순서로 진행할 예정이다. 요약하면 이 코어는 작은 빅코어가 아니라 전력 중심 사고로 재구성된 리틀코어이고, 복잡한 실행단 스케줄링 대신 분류를 잘하고 미리 깨우고 단순하게 흘려보내는 컨트롤 중심 구조를 통해 실사용 효율을 극대화하며, 미들/빅 코어를 자주 깨우지 않기 위한 최후의 방어선이 되는 것을 목표로 한다.


